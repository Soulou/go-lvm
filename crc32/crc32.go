package crc32

import (
	"bytes"
	"encoding/binary"
	"io"
)

func Calc(init uint32, buffer []byte) uint32 {
	var word uint32
	crc := init

	reader := bytes.NewReader(buffer)
	err := binary.Read(reader, binary.LittleEndian, &word)
	for err != io.EOF {
		crc = crc ^ word
		crc = crcTable[crc&0xff] ^ crc>>8
		crc = crcTable[crc&0xff] ^ crc>>8
		crc = crcTable[crc&0xff] ^ crc>>8
		crc = crcTable[crc&0xff] ^ crc>>8
		err = binary.Read(reader, binary.LittleEndian, &word)
	}

	return crc
}

// static uint32_t _calc_crc_new(uint32_t initial, const uint8_t *buf, uint32_t size)
// #endif
// {
//         /* CRC-32 byte lookup table generated by crc_gen.c */
//         };
//         const uint32_t *start = (const uint32_t *) buf;
//         const uint32_t *end = (const uint32_t *) (buf + (size & 0xfffffffc));
//         uint32_t crc = initial;

//         /* Process 4 bytes per iteration */
//         while (start < end) {
//                 crc = crc ^ xlate32(*start++);
//                 crc = crctab[crc & 0xff] ^ crc >> 8;
//                 crc = crctab[crc & 0xff] ^ crc >> 8;
//                 crc = crctab[crc & 0xff] ^ crc >> 8;
//                 crc = crctab[crc & 0xff] ^ crc >> 8;
//         }

//         /* Process any bytes left over */
//         buf = (const uint8_t *) start;
//         size = size & 0x3;
//         while (size--) {
//                 crc = crc ^ *buf++;
//                 crc = crctab[crc & 0xff] ^ crc >> 8;
//         }

//         return crc;
